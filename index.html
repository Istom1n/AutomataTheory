<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<title>AutomataTheory</title>


<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>

<style type="text/css">
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
	color: black;
	background: none;
	text-shadow: 0 1px white;
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
	text-shadow: none;
	background: #b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
	text-shadow: none;
	background: #b3d4fc;
}

@media print {
	code[class*="language-"],
	pre[class*="language-"] {
		text-shadow: none;
	}
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #f5f2f0;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: slategray;
}

.token.punctuation {
	color: #999;
}

.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
	color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
	color: #a67f59;
	background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
	color: #07a;
}

.token.function {
	color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
	color: #e90;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}
</style>


</head>

<body>

<h2 id="toc_0">Содержание</h2>

<p>Завершено | <u>Не завершено</u></p>

<ol>
<li>Конечные автоматы

<ul>
<li>НКА, ДКА</li>
<li>Алфавит, Слово, Язык</li>
<li>Регулярные выражения</li>
<li>Алгоритмы: РВ \(\Rightarrow\) НКА \(\Rightarrow\) ДКА \(\Rightarrow\) min ДКА</li>
</ul></li>
<li>Сети Петри

<ul>
<li>Определения:

<ul>
<li>разметка,</li>
<li>граф достижимости,</li>
<li>безопасность,</li>
<li>ограниченность,</li>
<li>живость,</li>
<li>сети свободного выбора – free choice,</li>
<li>моделирование.</li>
</ul></li>
<li>Анализ поведения:

<ul>
<li>граф достижимости,</li>
<li><u>инварианты</u>,</li>
<li>ловушки (traps),</li>
<li>co-traps.</li>
</ul></li>
<li>Цветные сети Петри (<u>моделирование процессов</u>)</li>
<li>Системы переходов:

<ul>
<li>Элементарные системы переходов,</li>
<li>Регионы,</li>
<li>Синтез сетей Петри по элементарным системам переходов.</li>
</ul></li>
</ul></li>
<li>Сети потоков работ (workflow nets, WF-сети):

<ul>
<li>Определение,</li>
<li>Конфликты,</li>
<li><u>Корректность (soundness)</u>,</li>
<li><u>Анализ поведения</u>.</li>
</ul></li>
<li><u>Графы потоков работ (workflow graphs)</u>.</li>
<li>Языки моделирования бизнес-процессов:

<ul>
<li>BPMN,</li>
<li>Диаграмма деятельности (UML Activity),</li>
<li>ARIS,</li>
<li><u>перспективы потока управления, данных, ресурсов</u>.</li>
</ul></li>
<li>Cистемы управления потоками работ.</li>
<li>Process mining (извлечение и анализ процессов):

<ul>
<li>Основные идеи</li>
<li>Альфа алгоритм</li>
</ul></li>
<li>Литература</li>
</ol>

<h2 id="toc_1">Конечные автоматы</h2>

<p><strong>Конечный автомат</strong> — абстрактный автомат, число возможных внутренних состояний которого конечно.</p>

<p><strong>Алфавит</strong> (англ. <em>alphabet</em>) — конечное непустое множество символов. Условимся обозначать алфавит большой греческой буквой \(\Sigma\).</p>

<p><strong>Слово</strong> (англ. <em>string</em>) или <strong>цепочка</strong> — конечная последовательность символов некоторого алфавита.</p>

<p><strong>Язык</strong> (англ. <em>language</em>) над алфавитом \(\Sigma\) — некоторое подмножество \(\Sigma^*\). Иногда такие языки называют <strong>формальными</strong> (англ. <em>formal</em>), чтобы подчеркнуть отличие от языков в привычном смысле.</p>

<p>Отметим, что язык в \(\Sigma\) не обязательно должен содержать цепочки, в которые входят все символы \(\Sigma\). Поэтому, если известно, что \(L\) является языком над \(\Sigma\), то можно утверждать, что \(L\) — это язык над любым алфавитом, являющимся надмножеством \(\Sigma\).</p>

<p><strong>Детерминированный конечный автомат (ДКА)</strong> — набор из пяти элементов \(\langle \Sigma , Q, s \in Q, T \subset Q, \delta : Q \times \Sigma \to Q \rangle\), где:</p>

<ul>
<li>\(\Sigma\) — алфавит (англ. <em>alphabet</em>), </li>
<li>\(Q\) — множество состояний (англ. <em>finite set of states</em>), </li>
<li>\(s\) — начальное (стартовое) состояние (англ. <em>start state</em>), </li>
<li>\(T\) — множество допускающих состояний (англ. <em>set of accept states</em>), </li>
<li>\(\delta\) — функция переходов (англ. <em>transition function</em>).</li>
</ul>

<h5 id="toc_2">Пример №1</h5>

<p><img src="http://neerc.ifmo.ru/wiki/images/f/f8/Automata_Search.png" alt="Автомат для поиска образца в тексте для строки abbab."></p>

<p><em>Автомат для поиска образца в тексте для строки abbab.</em></p>

<h5 id="toc_3">Пример №2</h5>

<p><img src="https://istomin.im/gc/dka_exp.png" alt=""></p>

<p><em>а) При анализе цепочки w = ababa автомат из примера 3.3, а, может сделать
следующую последовательность тактов:
\[(1, ababa) \vdash (1, baba) \vdash (1, aba) \vdash (2, ba) \vdash (3, a) \vdash (4, e)\]
Состояние 4 является заключительным, следовательно, цепочка w допус-
кается этим автоматом.<br>
б) При анализе цепочки w = ababab автомат из примера 3.3, б, должен сде-
лать следующую последовательность тактов:
\[(1, ababab) \vdash (2, babab) \vdash (7, abab) \vdash (8, bab) \vdash (7, ab) \vdash (8, b) \vdash (7, e).\]
Так как состояние 7 не является заключительным, цепочка w не допуска-
ется этим автоматом.</em></p>

<p><a href="http://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B5%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BE%D0%BD%D0%B5%D1%87%D0%BD%D1%8B%D0%B5_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D1%8B">Ссылка на вики</a></p>

<p><strong>Недетерминированный конечный автомат (НКА)</strong> — пятёрка \(\langle \Sigma , Q, s \in Q, T \subset Q, \delta : Q \times \Sigma \to 2^Q \rangle\), где: </p>

<ul>
<li>\(\Sigma\) — алфавит, </li>
<li>\(Q\) — множество состояний автомата, </li>
<li>\(s\) — начальное состояние автомата, </li>
<li>\(T\) — множество допускающих состояний автомата, </li>
<li>\(\delta\) — функция переходов.</li>
</ul>

<p>Таким образом, единственное отличие НКА от ДКА — существование нескольких переходов по одному символу из одного состояния.</p>

<h5 id="toc_4">Пример</h5>

<p><img src="http://neerc.ifmo.ru/wiki/images/b/b2/Finite_state_machine_4.png" alt="Автомат для поиска образца в тексте для строки abbab."></p>

<p><em>Это НКА, который распознает язык из алфавита \(\lbrace 0, 1 \rbrace\), где на четвертой с конца позиции стоит 0.</em></p>

<p><a href="http://neerc.ifmo.ru/wiki/index.php?title=%D0%9D%D0%B5%D0%B4%D0%B5%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BE%D0%BD%D0%B5%D1%87%D0%BD%D1%8B%D0%B5_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D1%8B">Ссылка на вики</a></p>

<p><strong>Регулярное выражение</strong> (англ. <em>regular expression</em>) над алфавитом \( \Sigma = \left\{c_1, c_2, \ldots ,c_k \right\} \) — способ порождения языка над \(\Sigma\). Определяется рекурсивно следующим образом:</p>

<ul>
<li>Для любого \(i\) слово \(c_i\) является регулярным выражением, задающим язык из одного слова \(c_i\).</li>
<li>\(\varepsilon\) является регулярным выражением, задающим язык из одной пустой строки, а \(\varnothing\) — пустой язык.</li>
<li>Если \(\alpha_1\) и \(\alpha_2\) являются регулярными выражениями, задающими языки \(L_1\) и \(L_2\) соответственно, то \((\alpha_1)|(\alpha_2)\) — регулярное выражение, задающее \(L_1 \bigcup L_2\).</li>
<li>Если \(\alpha_1\) и \(\alpha_2\) являются регулярными выражениями, задающими языки \(L_1\) и \(L_2\) соответственно, то \((\alpha_1)(\alpha_2)\) — регулярное выражение, задающее \(L_1L_2\).</li>
<li>Если \(\alpha_1\) является регулярным выражением, задающим язык \(L_1\), то \((\alpha_1)^*\) — регулярное выражение, задающее \(L_1^*\).</li>
<li>Операции указаны в порядке возрастания приоритета, при этом скобки повышают приоритет аналогично арифметическим выражениям.</li>
</ul>

<h5 id="toc_5">Пример</h5>

<p>\((a|b)^*abb\)</p>

<h2 id="toc_6">Алгоритмы: РВ \(\Rightarrow\) НКА \(\Rightarrow\) ДКА \(\Rightarrow\) min ДКА</h2>

<h3 id="toc_7">РВ \(\Rightarrow\) НКА</h3>

<p><img src="https://istomin.im/gc/re_nka.png" alt=""></p>

<h3 id="toc_8">НКА \(\Rightarrow\) ДКА</h3>

<p>Пусть нам дан недетерминированный конечный автомат: </p>

<p><img src="http://neerc.ifmo.ru/wiki/images/2/2a/DKA.png" alt=""></p>

<p>По нашему заданию эквивалентного ДКА мы получаем:</p>

<p><img src="http://neerc.ifmo.ru/wiki/images/3/3f/NKA_definition.png" alt=""></p>

<ol>
<li>Помещаем в очередь множество из одной стартовой вершины — \(\{1\}\): \(Q = \{\{1\}\}\).</li>
<li>Достаём из очереди множество \(\{1\}\): \(Q = \{\}\).</li>
<li>\(q_d(\{1\}, a) = \{1, 2\}\), кладём множество \(\{1, 2\}\) в очередь: \(Q = \{\{1, 2\}\}\).</li>
<li>\(q_d(\{1\}, b) = \{1\}\), нам не надо класть множество \(\{1\}\) в очередь, так как оно уже там было.</li>
<li>Достаём из очереди множество \(\{1, 2\}\): \(Q = \{\}\).</li>
<li>\(q_d(\{1, 2\}, a) = \{1, 2\}\), нам не надо класть множество \(\{1, 2\}\) в очередь, так как оно уже там было.</li>
<li>\(q_d(\{1, 2\}, b) = \{1, 2\}\), нам не надо класть множество \(\{1, 2\}\) в очередь, так как оно уже там было.</li>
<li>Помечаем все терминальные вершины, в данном случае — \(\{1, 2\}\).</li>
</ol>

<p>В итоге получаем ДКА, эквивалентный исходному:</p>

<p><img src="http://neerc.ifmo.ru/wiki/images/4/40/NKA_algorithm.png" alt=""></p>

<p><a href="http://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D0%BE_%D0%9D%D0%9A%D0%90_%D1%8D%D0%BA%D0%B2%D0%B8%D0%B2%D0%B0%D0%BB%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D0%B3%D0%BE_%D0%94%D0%9A%D0%90,_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%A2%D0%BE%D0%BC%D0%BF%D1%81%D0%BE%D0%BD%D0%B0">Описание алгоритма</a></p>

<h3 id="toc_9">Минимизация ДКА</h3>

<p><a href="http://neerc.ifmo.ru/wiki/index.php?title=%D0%9C%D0%B8%D0%BD%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D0%94%D0%9A%D0%90,_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%B7%D0%B0_O(n%5E2)_%D1%81_%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC_%D0%BF%D0%B0%D1%80_%D1%80%D0%B0%D0%B7%D0%BB%D0%B8%D1%87%D0%B8%D0%BC%D1%8B%D1%85_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B9">Описание алгоритма</a></p>

<h2 id="toc_10">Сети Петри</h2>

<p><strong>Сети Петри</strong> — математический аппарат для моделирования динамических дискретных систем. Впервые описаны Карлом Петри в 1962 году.</p>

<p>Сеть Петри представляет собой двудольный ориентированный мультиграф, состоящий из вершин двух типов — позиций и переходов, соединённых между собой дугами. Вершины одного типа не могут быть соединены непосредственно. В позициях могут размещаться метки (маркеры), способные перемещаться по сети.</p>

<p>Событием называют срабатывание перехода, при котором метки из входных позиций этого перехода перемещаются в выходные позиции. События происходят мгновенно, либо разновременно, при выполнении некоторых условий.</p>

<p>Сеть Петри есть мультиграф, так как он допускает существование кратных дуг от одной вершины графа к другой. Так как дуги являются направленными, то это ориентированный мультиграф. Вершины графа можно разделить на два множества (позиции и переходы) таким образом, что каждая дуга будет направлена от элемента одного множества (позиций или переходов) к элементу другого множества (переходов или позиций); следовательно, такой граф является двудольным ориентированным мультиграфом.</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/f/fe/Detailed_petri_net.png" alt="Пример сети Петри"></p>

<p><em>Пример сети Петри. Белыми кружками обозначены позиции, полосками — переходы, чёрными кружками — метки.</em></p>

<p><a href="http://baumanki.net/lectures/3-bezopasnost-zhiznedeyatelnosti-i-ohrana-truda/71-lekcii-po-sistemnomu-analizu-i-modelirovaniyu-v-chs/1251-tema-6-seti-petri.html">Описание сети Петри</a><br>
<a href="http://www.caree.narod.ru/vpdocs/part2.html">Еще одно описание</a> </p>

<p>Основными свойствами сети Петри являются:</p>

<ul>
<li><strong>ограниченность</strong> (англ. <em>bounded</em>) — число меток в любой позиции сети не может превысить некоторого значения \(K\);</li>
<li><strong>безопасность</strong> — частный случай ограниченности, \(K=1\);</li>
<li><strong>сохраняемость</strong> — постоянство загрузки ресурсов, \(\displaystyle \sum A_{i}N_{i}\) постоянна. Где \(\displaystyle N_{i}\)  — число маркеров в i-той позиции, \(\displaystyle A_{i}\)  — весовой коэффициент;</li>
<li><strong>достижимость</strong> — возможность перехода сети из одного заданного состояния (характеризуемого распределением меток) в другое;</li>
<li><strong>живость</strong> (англ. <em>live</em>) — любой переход может бы активирован из любой достижимой разметки сети Петри (за некоторое, возможно нулевое, число шагов).</li>
</ul>

<p><strong>Живость системы</strong> – это свойство системы характеризующее, что из любого состояния достижимого из начального возможен переход в любое другое достижимое состояние (или характеризует отсутствие в системе тупиков и зацикливаний).</p>

<p>Представим себе сеть Петри, изображающую структуру человеческого организма, где позиции соответствуют органам, дуги (с переходами) – кровеносным сосудам, фишки – некоторому стандартному объему крови. Если такая сеть не является ограниченной, то количество фишек в какой-либо позиции (и, соответственно, количество и давление крови в этом органе может возрастать) неограниченно. Что, естественно, соответствует кровоизлиянию.</p>

<p>Сети Петри, позволяя использовать такой подход, чаще применяются для <strong>моделирования процессов</strong>.</p>

<p><strong>Разметкой сети Петри</strong> называется число количества фишек в позициях. Совокупностью таких чисел для всех позиций сети называют <strong>разметкой сети</strong>. Позиция может и не содержать фишек, т.е. иметь <strong>нулевую разметку</strong>.</p>

<p><strong>Сети свободного выбор</strong> (<em>FC-сети</em> или <em>free choice</em>) — сети у которых каждая дуга, выходящая из позиции, является либо единственным выходом из нее, либо единственным входом в переход. FC-сети используются для описания процессов управления. Для сетей свободного выбора разработан механизм выявления ловушек и тупиков. Необходимое условие живости сети свободного выбора является то, что тупики должны содержать в себе ловушки. Следовательно, данная сеть живой не является.</p>

<p><strong>Путем сети</strong> – называется последовательность переходов и позиций, связанных направленными дугами. Если начало и конец пути совпадает, то такой путь называется циклом. Критерием близости живой свободной сети является возможность её покрытия циклами.</p>

<p><strong>Цветная сеть Петри</strong> — метки могут быть различных типов, обозначаемых цветами, тип метки может быть использован как аргумент в функциональных сетях.</p>

<h5 id="toc_11">Пример</h5>

<p>На рисунке «а» показана сеть Петри, а на рисунке «б» - соответствующий ей граф достижимых разметок.
Вершины графа на рисунке «б» соответствуют маркировкам (состояниям сети Петри), представленным в виде последовательности цифр, цифры означают количества меток в позициях, перечисляемых в порядке \(p_1, p_2, p_3, p_4, p_5\). Дуги помечены обозначениями срабатывающих переходов. Живость сети очевидна, так как срабатывают все переходы, тупики отсутствуют, сеть не является K – ограниченной.</p>

<p><img src="https://istomin.im/gc/graph_reachability.png" alt=""></p>

<p><strong>Инварианты</strong> —  </p>

<p><strong>Ловушки</strong> (англ. <em>traps</em>) — это множество позиций \(P&#39; \subseteq P\) таких, что выполнены условия \(\forall t \in T\) если \(\exists p_1 \in \bullet t\), \(p_1 \in P&#39;\), то \(\exists p_2 \in t \bullet\), \(p_2 \in P&#39;\).</p>

<p><img src="https://istomin.im/gc/traps_nets.png" alt=""></p>

<p>\(M(p_1) + \ldots + M(p_k) \ge 1\)</p>

<p><strong>Co-traps</strong> — это множество позиций \(P&#39;&#39; \subseteq P\) таких, что выполнены условия \(\forall t \in T\) если \(\exists p_1 \in t \bullet\), \(p_1 \in P&#39;&#39;\), то \(\exists p_2 \in \bullet t\), \(p_2 \in P&#39;&#39;\).</p>

<p><img src="https://istomin.im/gc/cotraps_nets.png" alt=""></p>

<p>\(M(p_1) + \ldots + M(p_k) = 0\)</p>

<h2 id="toc_12">Сети потоков работ (workflow nets, WF-сети)</h2>

<p><strong>WF-сети</strong> — подкласс сетей Петри, называемый также сетями потоков работ. Формализм WF-сетей введён Вил ван дер Аальстом (англ. Wil van der Aalst) для моделирования потоков работ в workflow-системах.</p>

<p>Сеть Петри \(PN = (P,T,F)\) называется сетью потоков работ (WF-сетью), если выполняются следующие условия:</p>

<ul>
<li>существует только одна исходная позиция \(i\), такая что отсутствуют переходы входящие в \(i\);</li>
<li>существует только одна конечная позиция \(o\), такая что отсутствуют переходы выходящие из \(o\);</li>
<li>каждый узел данной сети расположен на пути от \(i\) к \(о\).</li>
</ul>

<p>WF-сети используются для проверки <em>графов потоков работ</em> на наличие таких структурных конфликтов, как «тупики» (англ. <em>deadlocks</em>) и «недостатки синхронизации» (англ. <em>lack of synchronization</em>). Структурные конфликты отсутствуют, если WF-сеть является бездефектной.</p>

<p>Свойство бездефектности или правильной завершаемости соответствует следующим требованиям:</p>

<ul>
<li>конечная позиция o достижима при любой последовательности переходов от позиции \(i\);</li>
<li>WF-сеть не содержит лишних позиций (которые никогда не будут выполнены);</li>
<li>при достижении конечной позиции данной сети не должно оставаться фишек в промежуточных позициях.</li>
</ul>

<p>Свойство бездефектности соответствует двум хорошо известным свойствам сетей Петри — живости и ограниченности.</p>

<h2 id="toc_13">Графы потоков работ (workflow graphs)</h2>

<h2 id="toc_14">Языки моделирования бизнес-процессов</h2>

<p><strong>BPMN</strong> (англ. <em>Business Process Model and Notation</em>, нотация и модель бизнес-процессов)  — система условных обозначений (нотация) для моделирования бизнес-процессов.</p>

<p>Спецификация BPMN описывает условные обозначения для отображения бизнес-процессов в виде диаграмм бизнес-процессов. BPMN ориентирована как на технических специалистов, так и на бизнес-пользователей. Для этого язык использует базовый набор интуитивно понятных элементов, которые позволяют определять сложные семантические конструкции. Кроме того, спецификация BPMN определяет, как диаграммы, описывающие бизнес-процесс, могут быть трансформированы в исполняемые модели на языке BPEL. Спецификация BPMN 2.0 также является исполняемой и переносимой (то есть процесс, нарисованный в одном редакторе от одного производителя, может быть исполнен на движке бизнес-процессов совершенно другого производителя, при условии, если они поддерживают BPMN 2.0).</p>

<p>Основная цель BPMN — создание стандартного набора условных обозначений, понятных всем бизнес-пользователям. Бизнес-пользователи включают в себя бизнес-аналитиков, создающих и улучшающих процессы, технических разработчиков, ответственных за реализацию процессов и менеджеров, следящих за процессами и управляющих ими. Следовательно, BPMN призвана служить связующим звеном между фазой дизайна бизнес-процесса и фазой его реализации.</p>

<p>В настоящий момент существует несколько конкурирующих стандартов для моделирования бизнес-процессов. Распространение BPMN поможет унифицировать способы представления базовых концепций бизнес-процессов (например, открытые и частные бизнес-процессы, хореографии), а также более сложные концепции (например, обработка исключительных ситуаций, компенсация транзакций).</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/b/b2/Quotation_BPMN_Example.png" alt="Пример моделирования бизнес-процесса в нотации BPMN 1.1: Обработка запроса о товарах" title="Пример моделирования бизнес-процесса в нотации BPMN 1.1: Обработка запроса о товарах"></p>

<p>Моделирование в BPMN осуществляется посредством диаграмм с небольшим числом графических элементов. Это помогает пользователям быстро понимать логику процесса. Выделяют четыре основные категории элементов:</p>

<ul>
<li>Объекты потока управления: события, действия и логические операторы</li>
<li>Соединяющие объекты: поток управления, поток сообщений и ассоциации</li>
<li>Роли: пулы и дорожки</li>
<li>Артефакты: данные, группы и текстовые аннотации.</li>
</ul>

<p>Элементы этих четырёх категорий позволяют строить простейшие диаграммы бизнес-процессов. Для повышения выразительности модели спецификация разрешает создавать новые типы объектов потока управления и артефактов.</p>

<p>Объекты потока управления разделяются на три основных типа: события (events), действия (activities) и логические операторы (gateways).</p>

<p><a href="https://ru.wikipedia.org/wiki/BPMN">Ссылка на Википедию</a></p>

<p><strong>Диаграмма деятельности</strong> (англ. <em>activity diagram</em>) — UML-диаграмма, на которой показано разложение некоторой деятельности на её составные части. Под деятельностью (англ. <em>activity</em>) понимается спецификация исполняемого поведения в виде координированного последовательного и параллельного выполнения подчинённых элементов — вложенных видов деятельности и отдельных действий англ. <em>action</em>, соединённых между собой потоками, которые идут от выходов одного узла ко входам другого.</p>

<p>Диаграммы деятельности используются при моделировании бизнес-процессов, технологических процессов, последовательных и параллельных вычислений.</p>

<p>Диаграммы деятельности состоят из ограниченного количества фигур, соединённых стрелками. Основные фигуры:</p>

<p>Прямоугольники с закруглениями — действия:</p>

<ul>
<li>Ромбы — решения</li>
<li>Широкие полосы — начало (разветвление) и окончание (схождение) ветвления действий</li>
<li>Чёрный круг — начало процесса (начальное состояние)</li>
<li>Чёрный круг с обводкой — окончание процесса (конечное состояние)</li>
</ul>

<p>Стрелки идут от начала к концу процесса и показывают последовательность переходов.</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/e/e7/Activity_conducting.svg" alt="UML-диаграмма деятельности, отображающая процесс мозгового штурма."></p>

<p><em>UML-диаграмма деятельности, отображающая процесс мозгового штурма.</em></p>

<p><strong>ARIS</strong> (акроним от англ. <em>Architecture of Integrated Information Systems</em>) — методология и тиражируемый программный продукт для моделирования бизнес-процессов организаций.</p>

<p>Любая организация в методологии ARIS рассматривается с пяти точек зрения: организационной, функциональной, обрабатываемых данных, структуры бизнес-процессов, продуктов и услуг. При этом каждая из этих точек зрения разделяется ещё на три подуровня: описание требований, описание спецификации, описание внедрения. Для описания бизнес-процессов предлагается использовать около 80 типов моделей, каждая из которых принадлежит тому или иному аспекту. ARIS предоставляет визуальный инструментарий для обеспечения наглядности моделей. Также инструментарий поставляется с набором референтных моделей, заранее разработанных для типичных процессов в различных отраслях. Общий принцип в инструментарии — возможность интеграции моделей разных типов в рамках одного репозитория посредством декомпозиции (детализации) объектов. Таким образом, любую организацию можно описать с помощью иерархии моделей — от обобщения: например, процессы верхнего уровня с помощью модели VACD (англ. <em>value added chain diagram</em>) до уровня процедур и ресурсного окружения функций.</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/4/4c/ARIS_Model.jpg" alt=""></p>

<h2 id="toc_15">Системы управления потоками работ</h2>

<p><strong>Система автоматизации документооборота, система электронного документооборота</strong> (<strong>СЭДО</strong>) — автоматизированная многопользовательская система, сопровождающая процесс управления работой иерархической организации с целью обеспечения выполнения этой организацией своих функций. При этом предполагается, что процесс управления опирается на человеко-читаемые документы, содержащие инструкции для сотрудников организации, необходимые к исполнению.</p>

<p><img src="https://istomin.im/gc/msw_one.png" alt=""></p>

<p><img src="https://istomin.im/gc/msw_two.png" alt=""></p>

<h2 id="toc_16">Process mining</h2>

<p><strong>Управление процессом</strong> — это комплекс действий по планированию и мониторингу исполнения бизнес-процесса.</p>

<p><strong>Process mining</strong> (рус. <em>процесс добычи</em>) — это метод управления процессом, который позволяет анализировать бизнес-процессы на основе журналов событий (лог-файлов). Process mining использует специализированные алгоритмы интеллектуального анализа данных для извлечения данных из журналов событий, записанных с помощью информационных систем. Process mining направлен на эффективность и распознование процессов путем предоставления методов и средств для обнаружения процесса, управления, информации, организационных и социальных структур из журналов событий (лог-файлов).</p>

<p>Все это направлено на то, чтобы лучше анализировать данные в зависимости от имеющихся данных.</p>

<h4 id="toc_17">Альфа алгоритм</h4>

<p>Альфа алгоритм (англ <em>\(α\)-algorithm</em>) — это алгоритм использующийся в процессе добычи (process mining) направленных на преобразование событий из набора последовательностей событий.</p>

<p>Он создает сети Петри со специальными свойствами (WF-сети) основываясь на журлале событий.</p>

<p>Алгоритм берет журнал рабочего процесса (WF log) \(\displaystyle W\subseteq T^{*}\) в качестве входных данных и результат WF-сети начинает строиться.</p>

<p>Она делает это путем рассмотрения причинно-следственных связей наблюдающихся между задачами. Например, одна конкретная задача может всегда предшествовать другой конкретной задаче в каждый шаг выполнения, которая будет полезной информацией.</p>

<h4 id="toc_18">Пример</h4>

<ul>
<li>ABCD</li>
<li>ACBD</li>
<li>AED</li>
</ul>

<p><img src="https://istomin.im/gc/alpha_exp_one.png" alt=""></p>

<h2 id="toc_19">Литература и ссылки</h2>

<h4 id="toc_20">Конечные автоматы</h4>

<ul>
<li>Введение в теорию автоматов, языков и вычислений. Хопкрофт, Мотвани, Ульман (<a href="https://istomin.im/gc/Vvedenie_V_Teoriyu_Avtomatov_Yazykov_I_Vychisleni.pdf">.pdf</a>)</li>
<li>Основы конструирования компиляторов. В.А. Серебряков, М.П. Галочкин (<a href="http://www.ras.ru/ph/0005/NOV8QCSR.pdf">.pdf</a>)</li>
</ul>

<h4 id="toc_21">Сети Петри</h4>

<ul>
<li><a href="http://cpntools.org/">Программа для моделирований сети Петри</a></li>
<li>Wolfgang Reisig. Understanding Petri nets.</li>
<li>J. Desel and J. Esparza: Free Choice Petri Nets</li>
<li>Petri Nets Theory and The Modeling of Systems (<a href="http://webpages.iust.ac.ir/azgomi/Courses/MECS/eBooks/Petri%20Nets%20Theory%20and%20The%20Modeling%20of%20Systems.pdf">.pdf</a>)</li>
<li>Coloured Petri Nets. Kurt Jensen.</li>
<li>Jordi Cortadella, Michael Kishinevsky,Luciano Lavagno, and Alexandre Yakovlev, Deriving Petri Nets from Finite Transition Systems.</li>
</ul>

<h4 id="toc_22">Сети потоков работ</h4>

<ul>
<li>Workflow Management Models, methods and systems. Вил
ван дер Аалст. (<a href="http://wwwis.win.tue.nl/%7Ewvdaalst/publications/p120.pdf">.pdf</a>)</li>
<li>An Alternative Way to Analyze Workflow Graphs. W.M.P. van der Aalst, A. Hirnschall, and H.M.W. Verbeek. (<a href="http://wwwis.win.tue.nl/%7Ewvdaalst/publications/p155.pdf">.pdf</a>)</li>
<li><a href="http://www.workflowpatterns.com/">http://www.workflowpatterns.com/</a></li>
<li><a href="http://www.wfmc.org/">http://www.wfmc.org/</a></li>
</ul>

<h4 id="toc_23">Process mining</h4>

<ul>
<li>Process mining: Discovery, Conformance and Enhancement of Business Processes. Вил ван дер Аалст.</li>
<li>Process Mining: Beyond Business Intelligence (<a href="http://www.processmining.org/_media/presentations/processminingtutorialesscass-2009.pdf">.pdf</a>)</li>
</ul>

<h6 id="toc_24">View on <a href="https://github.com/Ivan-Istomin/AutomataTheory">GitHub</a></h6>



<script type="text/javascript">
var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(){var e=/\blang(?:uage)?-(\w+)\b/i,t=0,n=_self.Prism={util:{encode:function(e){return e instanceof a?new a(e.type,n.util.encode(e.content),e.alias):"Array"===n.util.type(e)?e.map(n.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++t}),e.__id},clone:function(e){var t=n.util.type(e);switch(t){case"Object":var a={};for(var r in e)e.hasOwnProperty(r)&&(a[r]=n.util.clone(e[r]));return a;case"Array":return e.map&&e.map(function(e){return n.util.clone(e)})}return e}},languages:{extend:function(e,t){var a=n.util.clone(n.languages[e]);for(var r in t)a[r]=t[r];return a},insertBefore:function(e,t,a,r){r=r||n.languages;var l=r[e];if(2==arguments.length){a=arguments[1];for(var i in a)a.hasOwnProperty(i)&&(l[i]=a[i]);return l}var o={};for(var s in l)if(l.hasOwnProperty(s)){if(s==t)for(var i in a)a.hasOwnProperty(i)&&(o[i]=a[i]);o[s]=l[s]}return n.languages.DFS(n.languages,function(t,n){n===r[e]&&t!=e&&(this[t]=o)}),r[e]=o},DFS:function(e,t,a,r){r=r||{};for(var l in e)e.hasOwnProperty(l)&&(t.call(e,l,e[l],a||l),"Object"!==n.util.type(e[l])||r[n.util.objId(e[l])]?"Array"!==n.util.type(e[l])||r[n.util.objId(e[l])]||(r[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,l,r)):(r[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,null,r)))}},plugins:{},highlightAll:function(e,t){var a={callback:t,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};n.hooks.run("before-highlightall",a);for(var r,l=a.elements||document.querySelectorAll(a.selector),i=0;r=l[i++];)n.highlightElement(r,e===!0,a.callback)},highlightElement:function(t,a,r){for(var l,i,o=t;o&&!e.test(o.className);)o=o.parentNode;o&&(l=(o.className.match(e)||[,""])[1],i=n.languages[l]),t.className=t.className.replace(e,"").replace(/\s+/g," ")+" language-"+l,o=t.parentNode,/pre/i.test(o.nodeName)&&(o.className=o.className.replace(e,"").replace(/\s+/g," ")+" language-"+l);var s=t.textContent,u={element:t,language:l,grammar:i,code:s};if(!s||!i)return n.hooks.run("complete",u),void 0;if(n.hooks.run("before-highlight",u),a&&_self.Worker){var c=new Worker(n.filename);c.onmessage=function(e){u.highlightedCode=e.data,n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,r&&r.call(u.element),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},c.postMessage(JSON.stringify({language:u.language,code:u.code,immediateClose:!0}))}else u.highlightedCode=n.highlight(u.code,u.grammar,u.language),n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,r&&r.call(t),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},highlight:function(e,t,r){var l=n.tokenize(e,t);return a.stringify(n.util.encode(l),r)},tokenize:function(e,t){var a=n.Token,r=[e],l=t.rest;if(l){for(var i in l)t[i]=l[i];delete t.rest}e:for(var i in t)if(t.hasOwnProperty(i)&&t[i]){var o=t[i];o="Array"===n.util.type(o)?o:[o];for(var s=0;s<o.length;++s){var u=o[s],c=u.inside,g=!!u.lookbehind,h=!!u.greedy,f=0,d=u.alias;u=u.pattern||u;for(var p=0;p<r.length;p++){var m=r[p];if(r.length>e.length)break e;if(!(m instanceof a)){u.lastIndex=0;var y=u.exec(m),v=1;if(!y&&h&&p!=r.length-1){var b=r[p+1].matchedStr||r[p+1],k=m+b;if(p<r.length-2&&(k+=r[p+2].matchedStr||r[p+2]),u.lastIndex=0,y=u.exec(k),!y)continue;var w=y.index+(g?y[1].length:0);if(w>=m.length)continue;var _=y.index+y[0].length,P=m.length+b.length;if(v=3,P>=_){if(r[p+1].greedy)continue;v=2,k=k.slice(0,P)}m=k}if(y){g&&(f=y[1].length);var w=y.index+f,y=y[0].slice(f),_=w+y.length,S=m.slice(0,w),O=m.slice(_),j=[p,v];S&&j.push(S);var A=new a(i,c?n.tokenize(y,c):y,d,y,h);j.push(A),O&&j.push(O),Array.prototype.splice.apply(r,j)}}}}}return r},hooks:{all:{},add:function(e,t){var a=n.hooks.all;a[e]=a[e]||[],a[e].push(t)},run:function(e,t){var a=n.hooks.all[e];if(a&&a.length)for(var r,l=0;r=a[l++];)r(t)}}},a=n.Token=function(e,t,n,a,r){this.type=e,this.content=t,this.alias=n,this.matchedStr=a||null,this.greedy=!!r};if(a.stringify=function(e,t,r){if("string"==typeof e)return e;if("Array"===n.util.type(e))return e.map(function(n){return a.stringify(n,t,e)}).join("");var l={type:e.type,content:a.stringify(e.content,t,r),tag:"span",classes:["token",e.type],attributes:{},language:t,parent:r};if("comment"==l.type&&(l.attributes.spellcheck="true"),e.alias){var i="Array"===n.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(l.classes,i)}n.hooks.run("wrap",l);var o="";for(var s in l.attributes)o+=(o?" ":"")+s+'="'+(l.attributes[s]||"")+'"';return"<"+l.tag+' class="'+l.classes.join(" ")+'" '+o+">"+l.content+"</"+l.tag+">"},!_self.document)return _self.addEventListener?(_self.addEventListener("message",function(e){var t=JSON.parse(e.data),a=t.language,r=t.code,l=t.immediateClose;_self.postMessage(n.highlight(r,n.languages[a],a)),l&&_self.close()},!1),_self.Prism):_self.Prism;var r=document.currentScript||[].slice.call(document.getElementsByTagName("script")).pop();return r&&(n.filename=r.src,document.addEventListener&&!r.hasAttribute("data-manual")&&document.addEventListener("DOMContentLoaded",n.highlightAll)),_self.Prism}();"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism);
</script>

<script type="text/x-mathjax-config">
if (typeof MathJaxListener !== 'undefined') {
  MathJax.Hub.Register.StartupHook('End', function () {
    MathJaxListener.invokeCallbackForKey_('End');
  });
}
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


</body>

</html>
