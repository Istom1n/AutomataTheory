##Содержание
[TOC]


##Конечные автоматы

**Конечный автомат** — абстрактный автомат, число возможных внутренних состояний которого конечно.

**Алфавит** (англ. *alphabet*) — конечное непустое множество символов. Условимся обозначать алфавит большой греческой буквой $\Sigma$.

**Слово** (англ. *string*) или **цепочка** — конечная последовательность символов некоторого алфавита.

**Язык** (англ. *language*) над алфавитом $\Sigma$ — некоторое подмножество $\Sigma^*$. Иногда такие языки называют **формальными** (англ. *formal*), чтобы подчеркнуть отличие от языков в привычном смысле.

Отметим, что язык в $\Sigma$ не обязательно должен содержать цепочки, в которые входят все символы $\Sigma$. Поэтому, если известно, что $L$ является языком над $\Sigma$, то можно утверждать, что $L$ — это язык над любым алфавитом, являющимся надмножеством $\Sigma$.

**Детерминированный конечный автомат (ДКА)** — набор из пяти элементов $\langle \Sigma , Q, s \in Q, T \subset Q, \delta : Q \times \Sigma \to Q \rangle$, где:

* $\Sigma$ — алфавит (англ. *alphabet*), 
* $Q$ — множество состояний (англ. *finite set of states*), 
* $s$ — начальное (стартовое) состояние (англ. *start state*), 
* $T$ — множество допускающих состояний (англ. *set of accept states*), 
* $\delta$ — функция переходов (англ. *transition function*).

#####Пример №1
![Автомат для поиска образца в тексте для строки abbab.](http://neerc.ifmo.ru/wiki/images/f/f8/Automata_Search.png)

*Автомат для поиска образца в тексте для строки abbab.*

#####Пример №2
![](https://istomin.im/gc/dka_exp.png)

*а) При анализе цепочки w = ababa автомат из примера 2, а, может сделать следующую последовательность тактов:
$$(1, ababa) \vdash (1, baba) \vdash (1, aba) \vdash (2, ba) \vdash (3, a) \vdash (4, e)$$
Состояние 4 является заключительным, следовательно, цепочка w допускается этим автоматом.  
б) При анализе цепочки w = ababab автомат из примера 2, б, должен сделать следующую последовательность тактов:
$$(1, ababab) \vdash (2, babab) \vdash (7, abab) \vdash (8, bab) \vdash (7, ab) \vdash (8, b) \vdash (7, e).$$
Так как состояние 7 не является заключительным, цепочка w не допускается этим автоматом.*

[Ссылка на вики](http://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B5%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BE%D0%BD%D0%B5%D1%87%D0%BD%D1%8B%D0%B5_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D1%8B)

**Недетерминированный конечный автомат (НКА)** — пятёрка $\langle \Sigma , Q, s \in Q, T \subset Q, \delta : Q \times \Sigma \to 2^Q \rangle$, где: 

* $\Sigma$ — алфавит, 
* $Q$ — множество состояний автомата, 
* $s$ — начальное состояние автомата, 
* $T$ — множество допускающих состояний автомата, 
* $\delta$ — функция переходов.

Таким образом, единственное отличие НКА от ДКА — существование нескольких переходов по одному символу из одного состояния.

#####Пример
![Автомат для поиска образца в тексте для строки abbab.](http://neerc.ifmo.ru/wiki/images/b/b2/Finite_state_machine_4.png)

*Это НКА, который распознает язык из алфавита $\lbrace 0, 1 \rbrace$, где на четвертой с конца позиции стоит 0.*

[Ссылка на вики](http://neerc.ifmo.ru/wiki/index.php?title=%D0%9D%D0%B5%D0%B4%D0%B5%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BE%D0%BD%D0%B5%D1%87%D0%BD%D1%8B%D0%B5_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D1%8B)

**Регулярное выражение** (англ. *regular expression*) над алфавитом $ \Sigma = \left\{c_1, c_2, \ldots ,c_k \right\} $ — способ порождения языка над $\Sigma$. Определяется рекурсивно следующим образом:

* Для любого $i$ слово $c_i$ является регулярным выражением, задающим язык из одного слова $c_i$.
* $\varepsilon$ является регулярным выражением, задающим язык из одной пустой строки, а $\varnothing$ — пустой язык.
* Если $\alpha_1$ и $\alpha_2$ являются регулярными выражениями, задающими языки $L_1$ и $L_2$ соответственно, то $(\alpha_1)|(\alpha_2)$ — регулярное выражение, задающее $L_1 \bigcup L_2$.
* Если $\alpha_1$ и $\alpha_2$ являются регулярными выражениями, задающими языки $L_1$ и $L_2$ соответственно, то $(\alpha_1)(\alpha_2)$ — регулярное выражение, задающее $L_1L_2$.
* Если $\alpha_1$ является регулярным выражением, задающим язык $L_1$, то $(\alpha_1)^*$ — регулярное выражение, задающее $L_1^*$.
* Операции указаны в порядке возрастания приоритета, при этом скобки повышают приоритет аналогично арифметическим выражениям.

#####Пример
$(a|b)^*abb$

##Алгоритмы: РВ $\Rightarrow$ НКА $\Rightarrow$ ДКА $\Rightarrow$ min ДКА

###РВ $\Rightarrow$ НКА
![](https://istomin.im/gc/re_nka.png)

###НКА $\Rightarrow$ ДКА
Пусть нам дан недетерминированный конечный автомат: 

![](http://neerc.ifmo.ru/wiki/images/2/2a/DKA.png)

По нашему заданию эквивалентного ДКА мы получаем:

![](http://neerc.ifmo.ru/wiki/images/3/3f/NKA_definition.png)

1. Помещаем в очередь множество из одной стартовой вершины — $\{1\}$: $Q = \{\{1\}\}$.
2. Достаём из очереди множество $\{1\}$: $Q = \{\}$.
3. $q_d(\{1\}, a) = \{1, 2\}$, кладём множество $\{1, 2\}$ в очередь: $Q = \{\{1, 2\}\}$.
4. $q_d(\{1\}, b) = \{1\}$, нам не надо класть множество $\{1\}$ в очередь, так как оно уже там было.
5. Достаём из очереди множество $\{1, 2\}$: $Q = \{\}$.
6. $q_d(\{1, 2\}, a) = \{1, 2\}$, нам не надо класть множество $\{1, 2\}$ в очередь, так как оно уже там было.
7. $q_d(\{1, 2\}, b) = \{1, 2\}$, нам не надо класть множество $\{1, 2\}$ в очередь, так как оно уже там было.
8. Помечаем все терминальные вершины, в данном случае — $\{1, 2\}$.

В итоге получаем ДКА, эквивалентный исходному:

![](http://neerc.ifmo.ru/wiki/images/4/40/NKA_algorithm.png)

[Описание алгоритма](http://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D0%BE_%D0%9D%D0%9A%D0%90_%D1%8D%D0%BA%D0%B2%D0%B8%D0%B2%D0%B0%D0%BB%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D0%B3%D0%BE_%D0%94%D0%9A%D0%90,_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%A2%D0%BE%D0%BC%D0%BF%D1%81%D0%BE%D0%BD%D0%B0)

###Минимизация ДКА

[Описание алгоритма](http://neerc.ifmo.ru/wiki/index.php?title=%D0%9C%D0%B8%D0%BD%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D0%94%D0%9A%D0%90,_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%B7%D0%B0_O(n%5E2)_%D1%81_%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC_%D0%BF%D0%B0%D1%80_%D1%80%D0%B0%D0%B7%D0%BB%D0%B8%D1%87%D0%B8%D0%BC%D1%8B%D1%85_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B9)

##Сети Петри

**Сети Петри** — математический аппарат для моделирования динамических дискретных систем. Впервые описаны Карлом Петри в 1962 году.

Сеть Петри представляет собой двудольный ориентированный мультиграф, состоящий из вершин двух типов — позиций и переходов, соединённых между собой дугами. Вершины одного типа не могут быть соединены непосредственно. В позициях могут размещаться метки (маркеры), способные перемещаться по сети.

Событием называют срабатывание перехода, при котором метки из входных позиций этого перехода перемещаются в выходные позиции. События происходят мгновенно, либо разновременно, при выполнении некоторых условий.

Сеть Петри есть мультиграф, так как он допускает существование кратных дуг от одной вершины графа к другой. Так как дуги являются направленными, то это ориентированный мультиграф. Вершины графа можно разделить на два множества (позиции и переходы) таким образом, что каждая дуга будет направлена от элемента одного множества (позиций или переходов) к элементу другого множества (переходов или позиций); следовательно, такой граф является двудольным ориентированным мультиграфом.

![Пример сети Петри](https://upload.wikimedia.org/wikipedia/commons/f/fe/Detailed_petri_net.png)

> Пример сети Петри. Белыми кружками обозначены позиции, полосками — переходы, чёрными кружками — метки.

[Описание сети Петри](http://baumanki.net/lectures/3-bezopasnost-zhiznedeyatelnosti-i-ohrana-truda/71-lekcii-po-sistemnomu-analizu-i-modelirovaniyu-v-chs/1251-tema-6-seti-petri.html)  
[Еще одно описание](http://www.caree.narod.ru/vpdocs/part2.html) 

Основными свойствами сети Петри являются:

* **ограниченность** (англ. *bounded*) — число меток в любой позиции сети не может превысить некоторого значения $K$;
* **безопасность** — частный случай ограниченности, $K=1$;
* **сохраняемость** — постоянство загрузки ресурсов, $\displaystyle \sum A_{i}N_{i}$ постоянна. Где $\displaystyle N_{i}$  — число маркеров в i-той позиции, $\displaystyle A_{i}$  — весовой коэффициент;
* **достижимость** — возможность перехода сети из одного заданного состояния (характеризуемого распределением меток) в другое;
* **живость** (англ. *live*) — любой переход может бы активирован из любой достижимой разметки сети Петри (за некоторое, возможно нулевое, число шагов).

**Живость системы** – это свойство системы характеризующее, что из любого состояния достижимого из начального возможен переход в любое другое достижимое состояние (или характеризует отсутствие в системе тупиков и зацикливаний).

Представим себе сеть Петри, изображающую структуру человеческого организма, где позиции соответствуют органам, дуги (с переходами) – кровеносным сосудам, фишки – некоторому стандартному объему крови. Если такая сеть не является ограниченной, то количество фишек в какой-либо позиции (и, соответственно, количество и давление крови в этом органе может возрастать) неограниченно. Что, естественно, соответствует кровоизлиянию.

Сети Петри, позволяя использовать такой подход, чаще применяются для **моделирования процессов**.

**Разметкой сети Петри** называется число количества фишек в позициях. Совокупностью таких чисел для всех позиций сети называют **разметкой сети**. Позиция может и не содержать фишек, т.е. иметь **нулевую разметку**.

**Сети свободного выбор** (*FC-сети* или *free choice*) — сети у которых каждая дуга, выходящая из позиции, является либо единственным выходом из нее, либо единственным входом в переход. FC-сети используются для описания процессов управления. Для сетей свободного выбора разработан механизм выявления ловушек и тупиков. Необходимое условие живости сети свободного выбора является то, что тупики должны содержать в себе ловушки. Следовательно, данная сеть живой не является.

**Путем сети** – называется последовательность переходов и позиций, связанных направленными дугами. Если начало и конец пути совпадает, то такой путь называется циклом. Критерием близости живой свободной сети является возможность её покрытия циклами.

**Цветная сеть Петри** — метки могут быть различных типов, обозначаемых цветами, тип метки может быть использован как аргумент в функциональных сетях.

#####Пример
На рисунке «а» показана сеть Петри, а на рисунке «б» - соответствующий ей граф достижимых разметок.
Вершины графа на рисунке «б» соответствуют маркировкам (состояниям сети Петри), представленным в виде последовательности цифр, цифры означают количества меток в позициях, перечисляемых в порядке $p_1, p_2, p_3, p_4, p_5$. Дуги помечены обозначениями срабатывающих переходов. Живость сети очевидна, так как срабатывают все переходы, тупики отсутствуют, сеть не является K – ограниченной.

![](https://istomin.im/gc/graph_reachability.png)

**Инварианты** —  


**Ловушки** (англ. *traps*) — это множество позиций $P' \subseteq P$ таких, что выполнены условия $\forall t \in T$ если $\exists p_1 \in \bullet t$, $p_1 \in P'$, то $\exists p_2 \in t \bullet$, $p_2 \in P'$.

![](https://istomin.im/gc/traps_nets.png)

$M(p_1) + \ldots + M(p_k) \ge 1$

**Co-traps** — это множество позиций $P'' \subseteq P$ таких, что выполнены условия $\forall t \in T$ если $\exists p_1 \in t \bullet$, $p_1 \in P''$, то $\exists p_2 \in \bullet t$, $p_2 \in P''$.

![](https://istomin.im/gc/cotraps_nets.png)

$M(p_1) + \ldots + M(p_k) = 0$

##Сети потоков работ (workflow nets, WF-сети)

**WF-сети** — подкласс сетей Петри, называемый также сетями потоков работ. Формализм WF-сетей введён Вил ван дер Аальстом (англ. Wil van der Aalst) для моделирования потоков работ в workflow-системах.

Сеть Петри $PN = (P,T,F)$ называется сетью потоков работ (WF-сетью), если выполняются следующие условия:

* существует только одна исходная позиция $i$, такая что отсутствуют переходы входящие в $i$;
* существует только одна конечная позиция $o$, такая что отсутствуют переходы выходящие из $o$;
* каждый узел данной сети расположен на пути от $i$ к $о$.

WF-сети используются для проверки *графов потоков работ* на наличие таких структурных конфликтов, как «тупики» (англ. *deadlocks*) и «недостатки синхронизации» (англ. *lack of synchronization*). Структурные конфликты отсутствуют, если WF-сеть является бездефектной.

Свойство бездефектности или правильной завершаемости соответствует следующим требованиям:

* конечная позиция o достижима при любой последовательности переходов от позиции $i$;
* WF-сеть не содержит лишних позиций (которые никогда не будут выполнены);
* при достижении конечной позиции данной сети не должно оставаться фишек в промежуточных позициях.

Свойство бездефектности соответствует двум хорошо известным свойствам сетей Петри — живости и ограниченности.

##Графы потоков работ (workflow graphs)


##Языки моделирования бизнес-процессов

**BPMN** (англ. *Business Process Model and Notation*, нотация и модель бизнес-процессов)  — система условных обозначений (нотация) для моделирования бизнес-процессов.

Спецификация BPMN описывает условные обозначения для отображения бизнес-процессов в виде диаграмм бизнес-процессов. BPMN ориентирована как на технических специалистов, так и на бизнес-пользователей. Для этого язык использует базовый набор интуитивно понятных элементов, которые позволяют определять сложные семантические конструкции. Кроме того, спецификация BPMN определяет, как диаграммы, описывающие бизнес-процесс, могут быть трансформированы в исполняемые модели на языке BPEL. Спецификация BPMN 2.0 также является исполняемой и переносимой (то есть процесс, нарисованный в одном редакторе от одного производителя, может быть исполнен на движке бизнес-процессов совершенно другого производителя, при условии, если они поддерживают BPMN 2.0).

Основная цель BPMN — создание стандартного набора условных обозначений, понятных всем бизнес-пользователям. Бизнес-пользователи включают в себя бизнес-аналитиков, создающих и улучшающих процессы, технических разработчиков, ответственных за реализацию процессов и менеджеров, следящих за процессами и управляющих ими. Следовательно, BPMN призвана служить связующим звеном между фазой дизайна бизнес-процесса и фазой его реализации.

В настоящий момент существует несколько конкурирующих стандартов для моделирования бизнес-процессов. Распространение BPMN поможет унифицировать способы представления базовых концепций бизнес-процессов (например, открытые и частные бизнес-процессы, хореографии), а также более сложные концепции (например, обработка исключительных ситуаций, компенсация транзакций).

![Пример моделирования бизнес-процесса в нотации BPMN 1.1: Обработка запроса о товарах](https://upload.wikimedia.org/wikipedia/commons/b/b2/Quotation_BPMN_Example.png "Пример моделирования бизнес-процесса в нотации BPMN 1.1: Обработка запроса о товарах")

Моделирование в BPMN осуществляется посредством диаграмм с небольшим числом графических элементов. Это помогает пользователям быстро понимать логику процесса. Выделяют четыре основные категории элементов:

* Объекты потока управления: события, действия и логические операторы
* Соединяющие объекты: поток управления, поток сообщений и ассоциации
* Роли: пулы и дорожки
* Артефакты: данные, группы и текстовые аннотации.

Элементы этих четырёх категорий позволяют строить простейшие диаграммы бизнес-процессов. Для повышения выразительности модели спецификация разрешает создавать новые типы объектов потока управления и артефактов.

Объекты потока управления разделяются на три основных типа: события (events), действия (activities) и логические операторы (gateways).

[Ссылка на Википедию](https://ru.wikipedia.org/wiki/BPMN)

**Диаграмма деятельности** (англ. *activity diagram*) — UML-диаграмма, на которой показано разложение некоторой деятельности на её составные части. Под деятельностью (англ. *activity*) понимается спецификация исполняемого поведения в виде координированного последовательного и параллельного выполнения подчинённых элементов — вложенных видов деятельности и отдельных действий англ. *action*, соединённых между собой потоками, которые идут от выходов одного узла ко входам другого.

Диаграммы деятельности используются при моделировании бизнес-процессов, технологических процессов, последовательных и параллельных вычислений.

Диаграммы деятельности состоят из ограниченного количества фигур, соединённых стрелками. Основные фигуры:

Прямоугольники с закруглениями — действия:

* Ромбы — решения
* Широкие полосы — начало (разветвление) и окончание (схождение) ветвления действий
* Чёрный круг — начало процесса (начальное состояние)
* Чёрный круг с обводкой — окончание процесса (конечное состояние)

Стрелки идут от начала к концу процесса и показывают последовательность переходов.

![UML-диаграмма деятельности, отображающая процесс мозгового штурма.](https://upload.wikimedia.org/wikipedia/commons/e/e7/Activity_conducting.svg)

*UML-диаграмма деятельности, отображающая процесс мозгового штурма.*

**ARIS** (акроним от англ. *Architecture of Integrated Information Systems*) — методология и тиражируемый программный продукт для моделирования бизнес-процессов организаций.

Любая организация в методологии ARIS рассматривается с пяти точек зрения: организационной, функциональной, обрабатываемых данных, структуры бизнес-процессов, продуктов и услуг. При этом каждая из этих точек зрения разделяется ещё на три подуровня: описание требований, описание спецификации, описание внедрения. Для описания бизнес-процессов предлагается использовать около 80 типов моделей, каждая из которых принадлежит тому или иному аспекту. ARIS предоставляет визуальный инструментарий для обеспечения наглядности моделей. Также инструментарий поставляется с набором референтных моделей, заранее разработанных для типичных процессов в различных отраслях. Общий принцип в инструментарии — возможность интеграции моделей разных типов в рамках одного репозитория посредством декомпозиции (детализации) объектов. Таким образом, любую организацию можно описать с помощью иерархии моделей — от обобщения: например, процессы верхнего уровня с помощью модели VACD (англ. *value added chain diagram*) до уровня процедур и ресурсного окружения функций.

![](https://upload.wikimedia.org/wikipedia/commons/4/4c/ARIS_Model.jpg)


##Системы управления потоками работ

**Система автоматизации документооборота, система электронного документооборота** (**СЭДО**) — автоматизированная многопользовательская система, сопровождающая процесс управления работой иерархической организации с целью обеспечения выполнения этой организацией своих функций. При этом предполагается, что процесс управления опирается на человеко-читаемые документы, содержащие инструкции для сотрудников организации, необходимые к исполнению.

![](https://istomin.im/gc/msw_one.png)

![](https://istomin.im/gc/msw_two.png)


##Process mining

**Управление процессом** — это комплекс действий по планированию и мониторингу исполнения бизнес-процесса.

**Process mining** (рус. *процесс добычи*) — это метод управления процессом, который позволяет анализировать бизнес-процессы на основе журналов событий (лог-файлов). Process mining использует специализированные алгоритмы интеллектуального анализа данных для извлечения данных из журналов событий, записанных с помощью информационных систем. Process mining направлен на эффективность и распознование процессов путем предоставления методов и средств для обнаружения процесса, управления, информации, организационных и социальных структур из журналов событий (лог-файлов).

Все это направлено на то, чтобы лучше анализировать данные в зависимости от имеющихся данных.

####Альфа алгоритм
Альфа алгоритм (англ *$α$-algorithm*) — это алгоритм использующийся в процессе добычи (process mining) направленных на преобразование событий из набора последовательностей событий.

Он создает сети Петри со специальными свойствами (WF-сети) основываясь на журлале событий.

Алгоритм берет журнал рабочего процесса (WF log) $\displaystyle W\subseteq T^{*}$ в качестве входных данных и результат WF-сети начинает строиться.

Она делает это путем рассмотрения причинно-следственных связей наблюдающихся между задачами. Например, одна конкретная задача может всегда предшествовать другой конкретной задаче в каждый шаг выполнения, которая будет полезной информацией.

####Пример

* ABCD
* ACBD
* AED

![](https://istomin.im/gc/alpha_exp_one.png)

##Литература и ссылки

####Конечные автоматы
* Введение в теорию автоматов, языков и вычислений. Хопкрофт, Мотвани, Ульман ([.pdf](https://istomin.im/gc/Vvedenie_V_Teoriyu_Avtomatov_Yazykov_I_Vychisleni.pdf))
* Основы конструирования компиляторов. В.А. Серебряков, М.П. Галочкин ([.pdf](http://www.ras.ru/ph/0005/NOV8QCSR.pdf))

####Сети Петри
* [Программа для моделирований сети Петри](http://cpntools.org/)
* Wolfgang Reisig. Understanding Petri nets.
* J. Desel and J. Esparza: Free Choice Petri Nets
* Petri Nets Theory and The Modeling of Systems ([.pdf](http://webpages.iust.ac.ir/azgomi/Courses/MECS/eBooks/Petri%20Nets%20Theory%20and%20The%20Modeling%20of%20Systems.pdf))
* Coloured Petri Nets. Kurt Jensen.
* Jordi Cortadella, Michael Kishinevsky,Luciano Lavagno, and Alexandre Yakovlev, Deriving Petri Nets from Finite Transition Systems.

####Сети потоков работ
* Workflow Management Models, methods and systems. Вил
ван дер Аалст. ([.pdf](http://wwwis.win.tue.nl/~wvdaalst/publications/p120.pdf))
* An Alternative Way to Analyze Workflow Graphs. W.M.P. van der Aalst, A. Hirnschall, and H.M.W. Verbeek. ([.pdf](http://wwwis.win.tue.nl/~wvdaalst/publications/p155.pdf))
* [http://www.workflowpatterns.com/](http://www.workflowpatterns.com/)
* [http://www.wfmc.org/](http://www.wfmc.org/)

####Process mining
* Process mining: Discovery, Conformance and Enhancement of Business Processes. Вил ван дер Аалст.
* Process Mining: Beyond Business Intelligence ([.pdf](http://www.processmining.org/_media/presentations/processminingtutorialesscass-2009.pdf))

######View on [GitHub](https://github.com/Ivan-Istomin/AutomataTheory), made by Ivan Istomin